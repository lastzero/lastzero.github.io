<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unit Testing on Liquid Bytes - Software Engineering &amp; Management Blog</title>
    <link>https://blog.liquidbytes.net/categories/unit-testing/</link>
    <description>Recent content in Unit Testing on Liquid Bytes - Software Engineering &amp; Management Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>You are free to share if you link back</copyright>
    <lastBuildDate>Fri, 04 Dec 2015 23:28:34 +0000</lastBuildDate>
    
	<atom:link href="https://blog.liquidbytes.net/categories/unit-testing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Hosted continuous integration services for PHP</title>
      <link>https://blog.liquidbytes.net/2015/12/hosted-continuous-integration-services-php/</link>
      <pubDate>Fri, 04 Dec 2015 23:28:34 +0000</pubDate>
      
      <guid>https://blog.liquidbytes.net/2015/12/hosted-continuous-integration-services-php/</guid>
      <description>Today, I&amp;#8217;ve been evaluating popular hosted CI services to see how well they&amp;#8217;re working with PHP and how much they cost.
drone.io https://drone.io/
drone.io is free for Open Source projects (one concurrent build). Paid plans for private repositories start at 25 $ / month. Builds are configured on the Web site. PHP support is marked as &amp;#8220;beta&amp;#8221; for good reasons: PHP 5.5.1 and composer are pretty much outdated. By default, builds are triggered by commits to all branches (can be limited).</description>
    </item>
    
    <item>
      <title>Why less mocking can improve everyone’s testing experience</title>
      <link>https://blog.liquidbytes.net/2015/11/mocks-are-evil/</link>
      <pubDate>Sat, 21 Nov 2015 05:39:16 +0000</pubDate>
      
      <guid>https://blog.liquidbytes.net/2015/11/mocks-are-evil/</guid>
      <description>There&amp;#8217;s some confusion in the community concerning the use of mocks for unit testing. Mocking is creating objects that simulate the behaviour of real objects. I personally don&amp;#8217;t mock class dependencies by default but use real objects and test doubles via dependency injection.
Despite the success of this approach, many developers are still plagued by concerns that the resulting tests are just some sort of component or integration tests and not true unit tests.</description>
    </item>
    
    <item>
      <title>Dependent Symfony 2 Bundles and Testability</title>
      <link>https://blog.liquidbytes.net/2015/11/dependent-symfony-2-bundles-and-testability/</link>
      <pubDate>Tue, 03 Nov 2015 12:37:13 +0000</pubDate>
      
      <guid>https://blog.liquidbytes.net/2015/11/dependent-symfony-2-bundles-and-testability/</guid>
      <description>I just came across a question concerning Symfony 2 bundles and testability on Stack Overflow that I would like to share with you.

When using Symfony, inexperienced or insecure developers tend to use lots of existing bundles, because this seems to be the recommend way of building an application. Later, they wonder, why it&amp;#8217;s so hard to write unit and component tests or they write functional tests instead and call them unit tests, because this really seems to be the only possible way to write tests.</description>
    </item>
    
    <item>
      <title>Using SQL fixtures for database related unit tests</title>
      <link>https://blog.liquidbytes.net/2012/08/sql-fixtures-for-unit-tests/</link>
      <pubDate>Tue, 21 Aug 2012 11:19:03 +0000</pubDate>
      
      <guid>https://blog.liquidbytes.net/2012/08/sql-fixtures-for-unit-tests/</guid>
      <description>This is a short tutorial to show how to use fixtures for database related unit tests. The inspiration for this post came from a conversation I had at the recent PHP Unconference in Hamburg, Germany.
From my experience, the usual way to test database related classes is to use a special test database, that needs a reset before each run (drop the existing tables and import the test dump). That approach has several severe drawbacks, all observed in real life projects many, many times:</description>
    </item>
    
  </channel>
</rss>